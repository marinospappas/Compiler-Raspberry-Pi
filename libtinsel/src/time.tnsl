/*--
 *-- Time Module
 *-- Version 1, October 2022
 *-- Various time related functions
 *-- Marinos Pappas
 */
library time

var CLOCK_REALTIME: int = 0
var tv: int,
    tv1: int
var t_ptr: intptr

fun clock_gettime(clock: int, time_now: intptr) @external:void
fun time(time_t: intptr) @external:void
fun ctime(time_t: intptr) @external:string

// timeout for 1 - 999 millisecs
fun timeout_millisec(duration: int) :void {
    var start_msec: int
    var msec_now: int
    var msec_difference: int
    t_ptr = addr(tv)
    clock_gettime(CLOCK_REALTIME, t_ptr)
    start_msec = [t_ptr+4] / 1000000
    while (1) {
        clock_gettime(CLOCK_REALTIME, t_ptr)
        msec_now = [t_ptr+4] / 1000000
        msec_difference = msec_now - start_msec
        if (msec_difference < 0) {
		    msec_difference = msec_difference + 1000
		}
	    if (msec_difference >= duration) {
            return
        }
    }
}

// timeout for 1 - 999,999 microsecs
fun timeout_microsec(duration: int) :void {
    var start_usec: int
    var usec_now: int
    var usec_difference: int
    t_ptr = addr(tv)
    clock_gettime(CLOCK_REALTIME, t_ptr)
    start_usec = [t_ptr+4] / 1000
    while (1) {
        clock_gettime(CLOCK_REALTIME, t_ptr)
        usec_now = [t_ptr+4] / 1000
        usec_difference = usec_now - start_usec
        if (usec_difference < 0) {
		    usec_difference = usec_difference + 1000000
		}
	    if (usec_difference >= duration) {
            return
        }
    }
}

//
// timeout function
// accepts: duration of timeout
//          units: millisec, microsec, sec (default)
fun timeout(duration: int, unit: string) @global:void {
    if (unit == "millisec") {
        timeout_millisec(duration)
        return
    }
    if (unit == "microsec") {
        timeout_microsec(duration)
        return
    }
    var start_time: int,
        start_nsec: int,
        time_now: int,
        nsec_now: int,
        sec_difference: int,
        nsec_difference: int
    t_ptr = addr(tv)
    clock_gettime(CLOCK_REALTIME, t_ptr)
    start_time = [t_ptr]
    start_nsec = [t_ptr+4]
    while (1) {
        timeout_microsec(10)
        clock_gettime(CLOCK_REALTIME, t_ptr)
        time_now = [t_ptr]
        nsec_now = [t_ptr+4]
        sec_difference = time_now - start_time
        nsec_difference = nsec_now - start_nsec
        if (sec_difference >= duration) {
            if (nsec_difference > 0) {
                return
            }
        }
    }
}

//
// getlocaltimestr
// returns the local time as string
fun getlocaltimestr() @global:string {
    var time_t: int;
    time(addr(time_t));
    return ctime(addr(time_t));
}

endlibrary